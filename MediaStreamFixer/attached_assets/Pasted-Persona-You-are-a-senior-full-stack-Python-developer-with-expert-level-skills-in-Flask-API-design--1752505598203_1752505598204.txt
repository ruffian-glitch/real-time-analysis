Persona: You are a senior full-stack Python developer with expert-level skills in Flask, API design, and computer vision using MediaPipe. You are also highly proficient in integrating large language models (LLMs) like Google's Gemini Pro to build intelligent, interactive applications.

Core Request:
I have a web application with a React frontend and a Flask backend. Your mission is to build the complete backend functionality for an AI Fitness Coach. This involves three primary tasks:

Real Video Analysis: Implement video analysis logic using MediaPipe Pose. You will adapt the provided Python scripts to create a robust analysis module that processes uploaded videos of fitness drills.

Structured Data Output: The analysis must produce a detailed, structured JSON object for each video. This JSON will contain frame-by-frame data, repetition counts, form critiques, and other key metrics.

AI Chat Integration (RAG): You will create an AI chat feature. This involves building a new API endpoint that uses the generated JSON as context for a powerful LLM (like Google's Gemini Pro) to answer user questions about their performance, using the Retrieval-Augmented Generation (RAG) pattern.

The final system should provide a seamless flow: video upload -> analysis -> data visualization -> interactive, context-aware chat.

End-to-End Workflow:
Upload: The user selects a drill type (e.g., "squats") and uploads a video file from the React frontend.

Analyze API Call: The frontend sends the video and drill type to a new Flask endpoint: /api/analyze.

Processing: The Flask backend saves the video and calls a central analysis_module to process it. This module uses MediaPipe to perform pose estimation and calculate all relevant metrics based on the drill type.

JSON Response: The analysis module generates a detailed JSON object containing the full performance breakdown. The /api/analyze endpoint returns this JSON to the frontend.

Display: The React frontend uses the JSON to display the video player, overall metrics (reps, time), and graphs visualizing the performance data.

Chat Interaction: The user opens a chat window and asks a question like, "Was my back straight?" or "Show me my second rep."

Chat API Call: The frontend sends the user's question along with the analysis JSON (or a unique ID to retrieve it) to a new Flask endpoint: /api/chat.

RAG with Gemini: The /api/chat endpoint constructs a detailed prompt for the Gemini API. It includes the user's question and the entire analysis JSON as context. This prompt instructs Gemini to act as a fitness coach and answer the user's question based only on the provided data.

Actionable AI Response: Gemini returns a text response. If the query requires a video action (e.g., "Show me my second rep"), the prompt will guide Gemini to include a structured, parsable command in its response, like {"action": "play_segment", "start_frame": 150, "end_frame": 210}.

Final Response to Frontend: The Flask backend relays the AI's text response and any associated action command to the frontend, which then displays the message and performs the action (e.g., seeks the video player to the specified frames).

Detailed Implementation Steps:
1. analysis_module.py - The Core Logic
Create this new file. It will contain all video processing and metric calculation logic.

Imports:

import cv2
import mediapipe as mp
import numpy as np
import json
import os

MediaPipe Initialization:

mp_pose = mp.solutions.pose
pose = mp_pose.Pose(static_image_mode=False, min_detection_confidence=0.5, min_tracking_confidence=0.5)

Drill-Specific Functions: Create a dedicated, well-commented function for each drill (analyze_pushups, analyze_squats, etc.). Each function must take a video_path as input and return a dictionary matching the specified JSON structure. Use the user-provided scripts as a reference for the core logic (angle calculations, state changes) but implement it purely with MediaPipe.

analyze_pushups(video_path): Generate JSON with total_reps, and for each rep: rep_number, start_frame, end_frame, max_elbow_angle, min_elbow_angle, body_angle_at_bottom.

analyze_squats(video_path): Generate JSON with total_reps, and for each rep: rep_number, start_frame, end_frame, min_knee_angle, torso_angle_at_bottom.

analyze_situps(video_path): Generate JSON with total_reps, and for each rep: rep_number, start_frame, end_frame, hip_angle_top, hip_angle_bottom.

analyze_chair_hold(video_path): Generate JSON with total_hold_time, and a time_series_data array with objects containing timestamp, knee_angle, and hip_angle.

analyze_elbow_plank(video_path): Generate JSON with total_hold_time, and a time_series_data array with objects containing timestamp and body_angle.

analyze_single_leg_balance(video_path, leg_side): Must handle leg_side='left' or 'right'. Generate JSON with leg_side, total_balance_time, total_fouls, and a foul_data array with objects containing foul_number, timestamp, and frame_number.

Main Router Function:

def analyze_video(video_path, drill_type):
    """Main router function to call the correct analysis function."""
    if drill_type == 'pushups':
        return analyze_pushups(video_path)
    elif drill_type == 'squats':
        return analyze_squats(video_path)
    elif drill_type == 'situps':
        return analyze_situps(video_path)
    elif drill_type == 'chair_hold':
        return analyze_chair_hold(video_path)
    elif drill_type == 'elbow_plank':
        return analyze_elbow_plank(video_path)
    elif drill_type == 'single_leg_balance_right':
        return analyze_single_leg_balance(video_path, 'right')
    elif drill_type == 'single_leg_balance_left':
        return analyze_single_leg_balance(video_path, 'left')
    else:
        return {"error": "Invalid drill type specified"}

2. app.py - The Flask API
Modify your app.py to handle both analysis and chat.

Imports and Setup:

from flask import Flask, request, jsonify
from werkzeug.utils import secure_filename
import os
import json
# You will need to install the Google AI Python SDK: pip install google-generativeai
import google.generativeai as genai

from analysis_module import analyze_video 

app = Flask(__name__)
app.config['UPLOAD_FOLDER'] = 'uploads'
os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)

# Configure the Gemini API key
# It's best practice to load this from an environment variable
GEMINI_API_KEY = os.environ.get('GEMINI_API_KEY')
if GEMINI_API_KEY:
    genai.configure(api_key=GEMINI_API_KEY)

Analysis Endpoint (/api/analyze):

@app.route('/api/analyze', methods=['POST'])
def handle_analysis():
    if 'video' not in request.files:
        return jsonify({"error": "No video file provided"}), 400

    video_file = request.files['video']
    drill_type = request.form.get('drill_type')

    if not drill_type:
        return jsonify({"error": "No drill type specified"}), 400

    if video_file.filename == '':
        return jsonify({"error": "No selected file"}), 400

    if video_file:
        filename = secure_filename(video_file.filename)
        video_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)
        video_file.save(video_path)

        # Call the analysis function
        analysis_results = analyze_video(video_path, drill_type)

        # Clean up the uploaded file
        os.remove(video_path)

        return jsonify(analysis_results)

    return jsonify({"error": "An unknown error occurred"}), 500

Chat Endpoint (/api/chat):

@app.route('/api/chat', methods=['POST'])
def handle_chat():
    if not GEMINI_API_KEY:
        return jsonify({"error": "Gemini API key is not configured on the server."}), 500

    data = request.get_json()
    user_question = data.get('question')
    analysis_json = data.get('analysis_data') # The frontend sends the full JSON context

    if not user_question or not analysis_json:
        return jsonify({"error": "Missing question or analysis data"}), 400

    # Construct the prompt for the Gemini API (RAG)
    prompt = f"""
    You are an expert AI fitness coach. Your task is to answer the user's question based *strictly* on the performance data provided in the following JSON object. Do not make up information.

    **Performance Data:**
    ```json
    {json.dumps(analysis_json, indent=2)}
    ```

    **User's Question:** "{user_question}"

    **Instructions:**
    1.  Analyze the data to formulate a helpful and encouraging response.
    2.  If the user asks to see a specific moment (like a rep or a foul), identify the corresponding start and end frames from the data.
    3.  Your final response must be a single JSON object with two keys: "text_response" and "action".
    4.  The "text_response" should be your conversational answer.
    5.  The "action" key should be null if no video action is needed. If a video action is required, it must be a JSON object like: {{"type": "play_segment", "start_frame": START_FRAME, "end_frame": END_FRAME}}.

    Provide only the final JSON object in your response.
    """

    try:
        model = genai.GenerativeModel('gemini-pro')
        response = model.generate_content(prompt)

        # Clean up and parse the model's response
        ai_response_text = response.text.strip().replace('`', '')
        if ai_response_text.startswith('json'):
            ai_response_text = ai_response_text[4:]

        ai_response_json = json.loads(ai_response_text)
        return jsonify(ai_response_json)

    except Exception as e:
        print(f"Error calling Gemini API: {e}")
        # Provide a fallback response
        fallback_response = {
            "text_response": "I'm having trouble analyzing that right now. Please try asking in a different way.",
            "action": None
        }
        return jsonify(fallback_response), 500

Final Deliverables:
The complete, final code for analysis_module.py.

The complete, final code for the modified app.py, including both the /api/analyze and /api/chat endpoints.

Ensure all code is clean, well-commented, and directly usable in a Replit environment.

User-Provided Code for Reference:
(You will paste the full content of chairhold.py, squats.py, situps.py, elbow_plank.py, and right_leg_balance.py here when you give this prompt to the Replit AI.)